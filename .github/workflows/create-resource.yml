name: Create Resources

on:
  push:
    paths:
      - 'resource.json'
  workflow_dispatch:

jobs:
  create-resources:
    runs-on: ubuntu-latest

    steps:
    # Checkout the repository
    - name: Checkout repository
      uses: actions/checkout@v2

    # Install jq tool for JSON processing
    - name: Install jq
      run: |
        sudo apt-get update
        sudo apt-get install -y jq

    # Parse the JSON file and set environment variables
    - name: Parse JSON file
      id: parse_json
      run: |
        platform_type=$(jq -r '.PlatformType' resource.json)
        echo "platform_type=$platform_type" >> $GITHUB_ENV
        echo "Platform type is $platform_type"
        
        resources=$(jq '.Resources | length' resource.json)
        echo "num_resources=$resources" >> $GITHUB_ENV
        echo "Number of resources is $resources"

        for ((i=0; i<$resources; i++)); do
          resource=$(jq -c .Resources[$i] resource.json)
          resource_type=$(echo $resource | jq -r '.ResourceType')
          resource_name=$(echo $resource | jq -r '.ResourceName')
          echo "resource_${i}_type=$resource_type" >> $GITHUB_ENV
          echo "resource_${i}_name=$resource_name" >> $GITHUB_ENV
          echo "resource_${i}_config=$resource" >> $GITHUB_ENV

          echo "Resource $i: type=$resource_type, name=$resource_name, config=$resource"
        done

    # Configure Terraform CLI
    - name: Configure Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_version: 1.0.11

    # Set up AWS credentials from secrets
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1  # Update to the appropriate AWS region

    # Create AWS resources based on parsed JSON configuration
    - name: Create AWS Resources
      if: env.platform_type == 'AWS'
      run: |
        num_resources=${{ env.num_resources }}
        rm -f main.tf   # Ensure main.tf is clean before starting

        for ((i=0; i<$num_resources; i++)); do
          resource_type=$(eval echo "\${resource_${i}_type}")
          resource_name=$(eval echo "\${resource_${i}_name}")
          resource_config=$(eval echo "\${resource_${i}_config}")

          echo "Creating $resource_type named $resource_name"

          case $resource_type in
            S3)
              echo "resource \"aws_s3_bucket\" \"$resource_name\" {
                bucket = \"$resource_name\"
              }" >> main.tf
              ;;
            EC2)
              ami=$(echo $resource_config | jq -r '.Ami')
              instance_type=$(echo $resource_config | jq -r '.InstanceType')
              echo "resource \"aws_instance\" \"$resource_name\" {
                ami           = \"$ami\"
                instance_type = \"$instance_type\"
              }" >> main.tf
              ;;
            SNS)
              echo "resource \"aws_sns_topic\" \"$resource_name\" {
                name = \"$resource_name\"
              }" >> main.tf
              ;;
            *)
              echo "Unsupported resource type: $resource_type"
              exit 1
              ;;
          esac
        done

        terraform init
        terraform apply -auto-approve

    # Processing resources for Databricks and Snowflake
    - name: Process Databricks and Snowflake
      if: ${{ env.platform_type == 'DATABRICK' || env.platform_type == 'DATAFLAKE' }}
      run: |
        if [ "$platform_type" == "DATABRICK" ]; then
          echo "Processing Databricks resources..."
          # Add your Databricks related commands here
        elif [ "$platform_type" == "DATAFLAKE" ]; then
          echo "Processing Snowflake resources..."
          # Add your Snowflake related commands here
        fi
